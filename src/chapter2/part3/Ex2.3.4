Array 1: 1 2 3 4 5 6 7 8 9 10
Reason: j wil come all the way from 10 to 1. then 1 is exchanged with itself. As a result, after each iteration,
the subarray size only decreases by 1, hence the number of compares are N + N - 1 + N -2 + ... + 1 ~ N^2/2 (because
it needs N iterations to reduce the size of the right sub array to 1)

Array 2: 10 9 8 7 6 5 4 3 2 1
Reason: i will come all the way from 9 to 1. then 10 is exchanged with 1
1 9 8 7 6 5 4 3 2  | 10
The sub-array size is decreased by 1
1 | 9 8 7 6 5 4 3 2
Again, sub-array is decreased by 1
2 8 7 6 5 4 3 | 9
Again, sub-array is decreased by 1
...
=> ~ N^2 /2


Array 3: 1 10 9 8 7 6 5 4 3 2
The array that uses the worst number of compares is the array that the partitioning element is always either the
smallest element or the largest element

Array 4: 10 1 2 3 4 5 6 7 8 9 same
9 1 2 3 4 5 6 7 8 | 10
8 1 2 3 4 5 6 7 | 9
7 1 2 3 4 5 6 | 8
...

Array 5: 1 2 3 4 5 10 9 8 7 6
1 | 2 3 4 5 10 9 8 7 6
    2 | 3 4 5 10 9 8 7 6
    ...
    5 | 10 9 8 7 6
        6 9 8 7 | 10
        6 | 9 8 7
            7 8 | 9
            7 | 8
                8

Array 6: 1 2 3 4 10 9 8 7 6 5





