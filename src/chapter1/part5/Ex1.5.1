QuickFind. For every pair, every find() operation requires only 1 array access. We only need t count
union
N = 10
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 2 3 4 5 6 7 8 9

- 9 0: 2 array accesses for find(), N array accesses for read, 1 array accesses for update id[9] -> 0 => N + 3
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 2 3 4 5 6 7 8 0

- 3 4: N + 3 as well, id[3] to 4
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 2 4 4 5 6 7 8 0

- 5 8: N + 3 as well, id[5] to 8
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 2 4 4 8 6 7 8 0

- 7 2: N + 3, id[7] to 2
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 2 4 4 8 6 2 8 0

- 2 1: 2 + N + 2 (since id[7] =2 and id[2] = 2), update to 1
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 1 4 4 8 6 1 8 0

- 5 7: find(5) = 8, find(7) = 1 => 2 + N + 2 (id[8] = 8 and id[5] = 8) update to 1
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 0 1 1 4 4 1 6 1 1 0

- 0 3: find(0) = 0, find(3) = 4 => 2 + N + 2 (id[0] = 0 and id[9] = 0), update to 4
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 4 1 1 4 4 1 6 1 1 4

- 4 2: fin(4) = 4, find(2) = 1 => 2 + N + 4(id[0] = id[3] = id[4] = id[9] = 4), update to 1
idx:  0 1 2 3 4 5 6 7 8 9
id[]: 1 1 1 1 1 1 6 1 1 1